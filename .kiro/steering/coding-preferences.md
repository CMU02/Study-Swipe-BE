---
inclusion: always
---

# 코딩 선호도 - "이렇게 코드를 작성하세요"

## 기본 원칙

### 1️⃣ 단순성 우선

- 복잡한 솔루션보다 간단하고 명확한 코드를 선호합니다
- 과도한 엔지니어링을 피하고 필요한 기능만 구현합니다
- 한 번에 하나의 기능에 집중합니다

### 2️⃣ 코드 품질 표준

- **가독성**: 변수명과 함수명은 명확하고 설명적이어야 합니다
- **일관성**: 프로젝트 전체에서 동일한 코딩 스타일을 유지합니다
- **문서화**: 모든 함수와 클래스에 한글 주석을 추가합니다
- **테스트**: 핵심 기능에 대한 테스트 코드를 작성합니다

### 3️⃣ TypeScript 및 NestJS 규칙

- 엄격한 타입 검사를 사용합니다 (`strict: true`)
- 모든 함수의 반환 타입을 명시합니다
- DTO에는 `class-validator` 데코레이터를 사용합니다
- 의존성 주입을 적극 활용합니다

### 4️⃣ 데이터베이스 및 엔티티 규칙

- 모든 엔티티에 audit 필드를 포함합니다 (`createdAt`, `updatedAt`, `deletedAt`)
- 데이터베이스 컬럼명은 `snake_case`, TypeScript 속성명은 `camelCase`를 사용합니다
- 관계 설정 시 `@JoinColumn`을 명확히 지정합니다
- Soft delete를 기본으로 사용합니다

### 5️⃣ 에러 처리

- NestJS의 내장 예외 클래스를 사용합니다 (`NotFoundException`, `BadRequestException` 등)
- 한글로 사용자 친화적인 에러 메시지를 제공합니다
- 모든 비동기 작업에 적절한 에러 처리를 추가합니다

### 6️⃣ 보안 원칙

- 모든 민감한 데이터는 환경 변수로 관리합니다
- 비밀번호는 bcrypt로 해싱합니다 (최소 12 rounds)
- JWT 토큰에는 최소한의 정보만 포함합니다
- 입력 데이터는 항상 검증합니다

## 고급 규칙

### SOLID 원칙 준수

- **단일 책임 원칙**: 각 클래스와 함수는 하나의 책임만 가집니다
- **개방-폐쇄 원칙**: 확장에는 열려있고 수정에는 닫혀있어야 합니다
- **의존성 역전 원칙**: 추상화에 의존하고 구체화에 의존하지 않습니다

### 성능 고려사항

- N+1 쿼리 문제를 방지합니다
- 필요한 관계만 로드합니다 (`relations` 옵션 신중히 사용)
- 대용량 데이터 처리 시 페이지네이션을 구현합니다

### 코드 리뷰 체크리스트

- [ ] 함수명이 동작을 명확히 설명하는가?
- [ ] 한글 주석이 적절히 추가되었는가?
- [ ] 에러 처리가 적절한가?
- [ ] 타입 안정성이 보장되는가?
- [ ] 보안 취약점이 없는가?

## 금지사항

- `any` 타입 사용 금지 (불가피한 경우 주석으로 이유 명시)
- 하드코딩된 값 사용 금지 (상수나 환경변수 사용)
- 순환 참조 생성 금지
- 동기 방식의 파일 I/O 금지
- SQL 인젝션 취약점을 만들 수 있는 코드 금지
